#include <PID_v1.h>
#include "I2Cdev.h"
#include "MPU6050_6Axis_MotionApps20.h"
#include <Wire.h>

// MPU6050 + DMP
MPU6050 mpu;
bool dmpReady = false;
uint16_t packetSize;
uint8_t fifoBuffer[64];
float ypr[3];  // yaw pitch roll

// PID
double input = 0.0;
double setpoint = 0.0;
double output = 0.0;

// Tunning cho PID
double Kp = 10.0, Ki = 0.5, Kd = 0.1;
PID pid(&input, &output, &setpoint, Kp, Ki, Kd, DIRECT);

// Chân stepper 2 bánh
#define LEFT_STEP_PIN   2
#define LEFT_DIR_PIN    5

#define RIGHT_STEP_PIN  3
#define RIGHT_DIR_PIN   6

#define ENABLE_PIN      8

// Biến điều khiển stepper
volatile long stepIntervalLeft = 0;
volatile long stepIntervalRight = 0;

volatile bool stepStateLeft = false;
volatile bool stepStateRight = false;

const long MIN_STEP_INTERVAL = 5;
const long MAX_STEP_INTERVAL = 500;

// Timer1 ISR tạo xung stepper cho 2 bánh
ISR(TIMER1_COMPA_vect) {
  static long counterLeft = 0;
  static long counterRight = 0;

  // Left motor step
  if (stepIntervalLeft > 0) {
    if (++counterLeft >= stepIntervalLeft) {
      counterLeft = 0;
      stepStateLeft = !stepStateLeft;
      digitalWrite(LEFT_STEP_PIN, stepStateLeft);
    }
  }

  // Right motor step
  if (stepIntervalRight > 0) {
    if (++counterRight >= stepIntervalRight) {
      counterRight = 0;
      stepStateRight = !stepStateRight;
      digitalWrite(RIGHT_STEP_PIN, stepStateRight);
    }
  }
}

void updateStepperControl(double pidOutput) {
  // Chia lực điều khiển đều cho 2 bánh (cùng chiều, cùng tốc độ)
  if (abs(pidOutput) < 1) {
    stepIntervalLeft = 0;
    stepIntervalRight = 0;
    return;
  }

  if (pidOutput > 0) {
    digitalWrite(LEFT_DIR_PIN, LOW);
    digitalWrite(RIGHT_DIR_PIN, LOW);
  } else {
    digitalWrite(LEFT_DIR_PIN, HIGH);
    digitalWrite(RIGHT_DIR_PIN, HIGH);
  }

  long interval = 800 / abs(pidOutput);
  if (interval < MIN_STEP_INTERVAL) interval = MIN_STEP_INTERVAL;
  if (interval > MAX_STEP_INTERVAL) interval = MAX_STEP_INTERVAL;

  stepIntervalLeft = interval;
  stepIntervalRight = interval;
}

void setup() {
  Serial.begin(250000);
  Wire.begin();

  pinMode(LEFT_STEP_PIN, OUTPUT);
  pinMode(LEFT_DIR_PIN, OUTPUT);
  pinMode(RIGHT_STEP_PIN, OUTPUT);
  pinMode(RIGHT_DIR_PIN, OUTPUT);
  pinMode(ENABLE_PIN, OUTPUT);

  digitalWrite(ENABLE_PIN, LOW);  // Enable stepper drivers

  mpu.initialize();

  int devStatus = mpu.dmpInitialize();

  if (devStatus == 0) {
    mpu.setDMPEnabled(true);
    dmpReady = true;
    packetSize = mpu.dmpGetFIFOPacketSize();

    pid.SetMode(AUTOMATIC);
    pid.SetSampleTime(10);
    pid.SetOutputLimits(-400, 400);

    noInterrupts();

    // Timer1 setup 20kHz
    TCCR1A = 0;
    TCCR1B = 0;
    OCR1A = 79;
    TCCR1B |= (1 << WGM12);
    TCCR1B |= (1 << CS11);
    TIMSK1 |= (1 << OCIE1A);

    interrupts();

    Serial.println("DMP ready.");
  } else {
    Serial.print("DMP initialization failed: ");
    Serial.println(devStatus);
    while (1);
  }
}

void loop() {
  if (!dmpReady) return;

  uint16_t fifoCount = mpu.getFIFOCount();

  if (fifoCount == 1024) {
    mpu.resetFIFO();
    Serial.println("FIFO overflow! Reset FIFO.");
    return;
  }

  while (fifoCount >= packetSize) {
    mpu.getFIFOBytes(fifoBuffer, packetSize);

    Quaternion q;
    VectorFloat gravity;
    mpu.dmpGetQuaternion(&q, fifoBuffer);
    mpu.dmpGetGravity(&gravity, &q);
    mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);

    input = ypr[2] * 180 / PI;  // Góc roll

    pid.Compute();
    updateStepperControl(output);

    fifoCount -= packetSize;
  }

  static unsigned long lastPrint = 0;
  if (millis() - lastPrint > 200) {
    lastPrint = millis();
    Serial.print("Roll: ");
    Serial.print(input, 2);
    Serial.print(" | PID output: ");
    Serial.println(output, 2);
  }
}
